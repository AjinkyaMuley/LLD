Understanding the Liskov Substitution Principle (LSP) with C++ Example
The Liskov Substitution Principle (LSP) is one of the five SOLID principles of object-oriented programming. It ensures that a derived class can replace its base class without altering the correctness of the program.

Why is LSP Important?
Imagine we have a base class Vehicle, which is extended by Car, Motorcycle, and Bicycle. If the base class does not correctly define its behavior, replacing it with derived classes can cause unexpected errors or incorrect results.

LSP ensures that any subclass can be used in place of its parent class without breaking the program.

1. Breaking LSP: What’s Wrong in the Initial Approach?
The initial Java code you provided violates LSP in two ways:

Incorrect Default Behavior:

The base class Vehicle defines getNumberOfWheels() with a default value of 2, assuming all vehicles have 2 wheels.

This breaks expectations when a Car object (which has 4 wheels) replaces a Vehicle.

Lack of a Proper Engine Definition:

The EngineVehicle subclass introduces an Engine class, but Vehicle does not define a standard hasEngine() method.

This makes it unclear which vehicles have an engine, leading to unpredictable behavior.

Example of LSP Violation
Imagine this code:

cpp
Copy
Edit
Vehicle* v = new Car();
std::cout << v->getNumberOfWheels(); // This should return 4, but in the original approach, it returns 2!
This breaks the principle because Car cannot fully substitute Vehicle without altering expected behavior.

2. Fixing the Problem: LSP-Compliant Approach
To correctly follow Liskov Substitution Principle, we ensure that all derived classes truly fit within the definition of the base class.

✅ Steps to Fix LSP
Define an abstract base class (Vehicle)

It should only declare the methods every vehicle must implement (getNumberOfWheels() and hasEngine()).

This makes sure each vehicle explicitly defines its own number of wheels and engine presence.

Introduce an Interface for Engine Vehicles (EngineVehicle)

This ensures that only vehicles with an engine override hasEngine(), avoiding unnecessary methods in Bicycle.

Correctly Implement Each Vehicle Class

Car and Motorcycle inherit from EngineVehicle and must define getNumberOfWheels().

Bicycle inherits from Vehicle and must explicitly set hasEngine() to false.

